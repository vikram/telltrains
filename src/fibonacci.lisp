(in-package :com.sondesh.database)

(defstruct FibonacciHeap 
  min itemsToNodes removed)

(defclass FibonacciHeapNode ()
  ((userObject :accessor FibonacciHeapNode-userObject :initform nil)
   (priority :accessor FibonacciHeapNode-priority :initform most-positive-fixnum)
   (parent :accessor FibonacciHeapNode-parent :initform nil)
   (prevSibling :accessor FibonacciHeapNode-prevSibling :initform nil)
   (nextSibling :accessor FibonacciHeapNode-nextSibling :initform nil)
   (child :accessor FibonacciHeapNode-child :initform nil)
   (degree :accessor FibonacciHeapNode-degree :initform 0)
   (mark :accessor FibonacciHeapNode-mark :initform 'false)))

(defun init-heap ()
  (make-FibonacciHeap
   :min nil
   :itemsToNodes (make-hash-table :test 'equal)
   :removed (make-hash-table :test 'equal)))

(defun init-node (userObject priority)
  (let ((node (make-instance 'FibonacciHeapNode)))
    (setf (FibonacciHeapNode-userObject node) userObject)
    (setf (FibonacciHeapNode-priority node) priority)
    (setf (FibonacciHeapNode-parent node) nil)
    (setf (FibonacciHeapNode-prevSibling node) node)
    (setf (FibonacciHeapNode-nextSibling node) node)
    (setf (FibonacciHeapNode-child node) nil)
    (setf (FibonacciHeapNode-degree node) 0)
    (setf (FibonacciHeapNode-mark node) 'false)
    node))

(defun decreaseKey(heap item priority)
  (let ((node (gethash item (FibonacciHeap-itemsToNodes heap))))
    (unless (< (FibonacciHeapNode-priority node) priority)
      (setf (FibonacciHeapNode-priority node) priority)
      (let ((parent (FibonacciHeapNode-parent node)))
	(when (and parent
		   (< (FibonacciHeapNode-priority node) 
		      (FibonacciHeapNode-priority parent)))
	  (cut heap node parent)
	  (cascadingCut heap parent))
	(if (< (FibonacciHeapNode-priority node) 
	       (FibonacciHeapNode-priority (FibonacciHeap-min heap)))
	    (setf (FibonacciHeap-min heap) node))))))

(defun heap-add (heap item priority)
  (let ((newNode (init-node item priority)))
    (setf (gethash item (FibonacciHeap-itemsToNodes heap)) newNode)
    (if (not (FibonacciHeap-min heap))
	(setf (FibonacciHeap-min heap) newNode)
	(progn
	  (concatenateSiblings newNode (FibonacciHeap-min heap))
	  (if (< (FibonacciHeapNode-priority newNode) (FibonacciHeapNode-priority (FibonacciHeap-min heap)))
	      (setf (FibonacciHeap-min heap) newNode))))))

(defun heap-contains(heap item)
  (gethash item (FibonacciHeap-itemsToNodes heap)))

(defun removeFromSiblings(x)
  (when (not (equal (FibonacciHeapNode-nextSibling x) x))     
    (if (FibonacciHeapNode-nextSibling x)
	(setf (FibonacciHeapNode-prevSibling (FibonacciHeapNode-nextSibling x)) (FibonacciHeapNode-prevSibling x)))
    (if (FibonacciHeapNode-prevSibling x)
	(setf (FibonacciHeapNode-nextSibling (FibonacciHeapNode-prevSibling x)) (FibonacciHeapNode-nextSibling x)))
    (setf (FibonacciHeapNode-nextSibling x) x)
    (setf (FibonacciHeapNode-prevSibling x) x)))

(defun concatenateSiblings(a b)
  (progn
    (setf (FibonacciHeapNode-prevSibling (FibonacciHeapNode-nextSibling a)) b)
    (setf (FibonacciHeapNode-prevSibling (FibonacciHeapNode-nextSibling b)) a)
    (let ((origAnext (FibonacciHeapNode-nextSibling a)))
      (setf (FibonacciHeapNode-nextSibling a) (FibonacciHeapNode-nextSibling b))
      (setf (FibonacciHeapNode-nextSibling b) origAnext))))

(defun peekMin(heap)
  (if (not (FibonacciHeap-min heap))
      nil
      (FibonacciHeapNode-userObject (fibonacciHeap-min heap))))

(defun heap-size(heap)
  (hash-table-count (FibonacciHeap-itemsToNodes heap)))

(defun popMin(heap)
  (if (not (FibonacciHeap-min heap))
      nil
      (progn
	(let ((it (FibonacciHeapNode-child (FibonacciHeap-min heap))))
	  (when it
	    (while (FibonacciHeapNode-parent it)
	      (setf (FibonacciHeapNode-parent it) nil)
	      (setf it (FibonacciHeapNode-nextSibling it)))
	    (concatenateSiblings it (FibonacciHeap-min heap))))
	(let ((oldMin (FibonacciHeap-min heap)))
	  (if (equal (FibonacciHeapNode-nextSibling (FibonacciHeap-min heap))
		     (FibonacciHeap-min heap))
	      (setf (FibonacciHeap-min heap) nil)
	      (progn
		(setf (FibonacciHeap-min heap) (FibonacciHeapNode-nextSibling (FibonacciHeap-min heap)))
		(removeFromSiblings oldMin)
		(consolidate heap)))
	  (remhash (FibonacciHeapNode-userObject oldMin) (FibonacciHeap-itemsToNodes heap))
	  (setf (gethash (FibonacciHeapNode-userObject oldMin) (FibonacciHeap-removed heap)) oldMin)
	  oldMin))))

(defun make-newroots (size)
  (let ((newRoots (make-array (list size) :element-type 'FibonacciHeapNode)))
    (dotimes (i size)
      (setf (aref newRoots i) nil))
    newRoots))	

(defun consolidate(heap)
  (let* ((size (heap-size heap))
	 (newRoots (make-newroots size))
	 (node (FibonacciHeap-min heap))
	 (start (FibonacciHeap-min heap))
	 (first t))
    (while (or first (not (equal node start)))
      (setf first nil)
      (let ((x node)
	    (currDegree (FibonacciHeapNode-degree node)))
	(while (aref newRoots currDegree)
	  (let ((y (aref newRoots currDegree)))
	    (when (> (FibonacciHeapNode-priority x)
		     (FibonacciHeapNode-priority y))
	      (let ((tmp x))
		(setf x y)
		(setf y tmp)))
	    (if (equal y start)
		(setf start (FibonacciHeapNode-nextSibling start)))
	    (if (equal y node)
		(setf node (FibonacciHeapNode-prevSibling node)))
	    (link y x)
	    (setf (aref newRoots currDegree) nil)
	    (incf currDegree)))
	(setf (aref newRoots currDegree) x)
	(setf node (FibonacciHeapNode-nextSibling node))))
    (setf (FibonacciHeap-min heap) nil)
    (dotimes (i size)
      (when (and (aref newRoots i)
		 (or (not (FibonacciHeap-min heap))
		     (< (FibonacciHeapNode-priority (aref newRoots i))
			(FibonacciHeapNode-priority (FibonacciHeap-min heap)))))
	(setf (fibonacciheap-min heap) (aref newRoots i))))))

(defun link(y x)
  (progn
    (removeFromSiblings y)
    (setf (FibonacciHeapNode-parent y) x)
    (if (not (FibonacciHeapNode-child x))
	(setf (FibonacciHeapNode-child x) y)
	(concatenateSiblings (FibonacciHeapNode-child x) y))
    (incf (FibonacciHeapNode-degree x))
    (setf (FibonacciHeapNode-mark y) 'false)))

(defun cut(heap x y)
  (progn
    (if (equal (FibonacciHeapNode-child y) x)
	(setf (FibonacciHeapNode-child y) (FibonacciHeapNode-nextSibling x)))
    (if (equal (FibonacciHeapNode-child y) x)
	(setf (FibonacciHeapNode-child y) nil))
    (decf (FibonacciHeapNode-degree y))
    (removeFromSiblings x)
    (concatenateSiblings x (FibonacciHeap-min heap))
    (setf (FibonacciHeapNode-parent x) nil)
    (setf (FibonacciHeapNode-mark x) 'false)))

(defun cascadingCut(heap y)
  (let ((z (FibonacciHeapNode-parent y)))
    (if z
	(if (eql 'false (FibonacciHeapNode-mark y))   
	    (setf (FibonacciHeapNode-mark y) 'true)
	    (progn
	      (cut heap y z)
	      (cascadingCut heap z))))))

(defun make-heap (len)
  (let ((heap (init-heap)))
    (dotimes (i len)
      (heap-add heap (1+ i) most-positive-fixnum))
    heap))

(defun dist (heap index)
  (aif (gethash index (FibonacciHeap-itemsToNodes heap))
       (FibonacciHeapNode-priority it)
       (FibonacciHeapNode-priority (gethash index (FibonacciHeap-removed heap)))))

